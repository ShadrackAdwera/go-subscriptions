// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: users_packages.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createUserPackage = `-- name: CreateUserPackage :one
INSERT INTO users_packages (
  id, user_id, package_id, status, start_date, end_date
) VALUES (
  $1, $2, $3, $4, $5, $6
)
RETURNING id, user_id, package_id, status, start_date, end_date
`

type CreateUserPackageParams struct {
	ID        string             `json:"id"`
	UserID    int64              `json:"user_id"`
	PackageID int64              `json:"package_id"`
	Status    SubscriptionStatus `json:"status"`
	StartDate time.Time          `json:"start_date"`
	EndDate   time.Time          `json:"end_date"`
}

func (q *Queries) CreateUserPackage(ctx context.Context, arg CreateUserPackageParams) (UsersPackage, error) {
	row := q.db.QueryRowContext(ctx, createUserPackage,
		arg.ID,
		arg.UserID,
		arg.PackageID,
		arg.Status,
		arg.StartDate,
		arg.EndDate,
	)
	var i UsersPackage
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PackageID,
		&i.Status,
		&i.StartDate,
		&i.EndDate,
	)
	return i, err
}

const deleteUserPackage = `-- name: DeleteUserPackage :exec
DELETE FROM users_packages WHERE id = $1
`

func (q *Queries) DeleteUserPackage(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteUserPackage, id)
	return err
}

const getUserPackages = `-- name: GetUserPackages :many
SELECT users_packages.id, user_id, package_id, status, start_date, end_date, users.id, username, email, stripe_id, created_at, packages.id, name, description, price, stripe_price_id 
FROM users_packages 
JOIN users ON users_packages.user_id = users.id
JOIN packages ON users_packages.package_id = packages.id
`

type GetUserPackagesRow struct {
	ID            string             `json:"id"`
	UserID        int64              `json:"user_id"`
	PackageID     int64              `json:"package_id"`
	Status        SubscriptionStatus `json:"status"`
	StartDate     time.Time          `json:"start_date"`
	EndDate       time.Time          `json:"end_date"`
	ID_2          int64              `json:"id_2"`
	Username      string             `json:"username"`
	Email         string             `json:"email"`
	StripeID      string             `json:"stripe_id"`
	CreatedAt     time.Time          `json:"created_at"`
	ID_3          string             `json:"id_3"`
	Name          string             `json:"name"`
	Description   string             `json:"description"`
	Price         int64              `json:"price"`
	StripePriceID string             `json:"stripe_price_id"`
}

func (q *Queries) GetUserPackages(ctx context.Context) ([]GetUserPackagesRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserPackages)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserPackagesRow
	for rows.Next() {
		var i GetUserPackagesRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.PackageID,
			&i.Status,
			&i.StartDate,
			&i.EndDate,
			&i.ID_2,
			&i.Username,
			&i.Email,
			&i.StripeID,
			&i.CreatedAt,
			&i.ID_3,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.StripePriceID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUserPackage = `-- name: UpdateUserPackage :one
UPDATE users_packages 
SET
  package_id = COALESCE($1,package_id),
  status = COALESCE($2,status),
  start_date = COALESCE($3,start_date),
  end_date = COALESCE($4,end_date)
WHERE id = $5
RETURNING id, user_id, package_id, status, start_date, end_date
`

type UpdateUserPackageParams struct {
	PackageID sql.NullInt64          `json:"package_id"`
	Status    NullSubscriptionStatus `json:"status"`
	StartDate sql.NullTime           `json:"start_date"`
	EndDate   sql.NullTime           `json:"end_date"`
	ID        string                 `json:"id"`
}

func (q *Queries) UpdateUserPackage(ctx context.Context, arg UpdateUserPackageParams) (UsersPackage, error) {
	row := q.db.QueryRowContext(ctx, updateUserPackage,
		arg.PackageID,
		arg.Status,
		arg.StartDate,
		arg.EndDate,
		arg.ID,
	)
	var i UsersPackage
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PackageID,
		&i.Status,
		&i.StartDate,
		&i.EndDate,
	)
	return i, err
}
